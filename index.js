// Generated by CoffeeScript 1.6.3
(function() {
  var DEFAULT_MESSAGE_TIMEOUT, DEFAULT_WORKERS, DEFAULT_WORKER_ITERATIONS, DEFAULT_WORKER_PARALLELISM, PhantomClusterServer, PhantomClusterWorker, PhantomQueuedClusterServer, PhantomQueuedClusterWorker, QueueItem, STOP_QUEUE_CHECKING_INTERVAL, cluster, create, createQueued, empty, events, os, phantom,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  phantom = require("phantom");

  cluster = require("cluster");

  events = require("events");

  os = require("os");

  DEFAULT_WORKER_ITERATIONS = 100;

  DEFAULT_WORKER_PARALLELISM = 1;

  STOP_QUEUE_CHECKING_INTERVAL = 10;

  DEFAULT_MESSAGE_TIMEOUT = 60 * 1000;

  DEFAULT_WORKERS = os.cpus().length;

  empty = function(obj) {
    var key;
    for (key in obj) {
      return false;
    }
    return true;
  };

  create = function(options) {
    if (cluster.isMaster) {
      return new PhantomClusterServer(options);
    } else {
      return new PhantomClusterWorker(options);
    }
  };

  createQueued = function(options) {
    if (cluster.isMaster) {
      return new PhantomQueuedClusterServer(options);
    } else {
      return new PhantomQueuedClusterWorker(options);
    }
  };

  PhantomClusterServer = (function(_super) {
    __extends(PhantomClusterServer, _super);

    function PhantomClusterServer(options) {
      if (options == null) {
        options = {};
      }
      PhantomClusterServer.__super__.constructor.apply(this, arguments);
      options = options || {};
      this.numWorkers = options.workers || DEFAULT_WORKERS;
      this.workers = {};
      this.done = false;
    }

    PhantomClusterServer.prototype.addWorker = function() {
      var worker;
      worker = cluster.fork();
      this.workers[worker.id] = worker;
      return this.emit("workerStarted", worker);
    };

    PhantomClusterServer.prototype.start = function() {
      var i, _i, _ref,
        _this = this;
      cluster.on("exit", function(worker, code, signal) {
        _this.emit("workerDied", worker, code, signal);
        delete _this.workers[worker.id];
        if (!_this.done) {
          return _this.addWorker();
        }
      });
      for (i = _i = 0, _ref = this.numWorkers; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.addWorker();
      }
      return this.emit("started");
    };

    PhantomClusterServer.prototype.stop = function() {
      var worker, _, _ref;
      if (!this.done) {
        this.done = true;
        _ref = this.workers;
        for (_ in _ref) {
          worker = _ref[_];
          worker.kill();
        }
        return this.emit("stopped");
      }
    };

    return PhantomClusterServer;

  })(events.EventEmitter);

  PhantomClusterWorker = (function(_super) {
    __extends(PhantomClusterWorker, _super);

    function PhantomClusterWorker(options) {
      if (options == null) {
        options = {};
      }
      PhantomClusterWorker.__super__.constructor.apply(this, arguments);
      options = options || {};
      this.ph = null;
      this.iterations = options.workerIterations || DEFAULT_WORKER_ITERATIONS;
      this.parallelism = options.workerParallelism || DEFAULT_WORKER_PARALLELISM;
      this.phantomArguments = options.phantomArguments || [];
      this.phantomBinary = options.phantomBinary || require("phantomjs").path;
      this.phantomBasePort = options.phantomBasePort || 12300;
      this.pendingRequestCount = 0;
      this.onStdout = options.onStdout;
      this.onStderr = options.onStderr;
      this.done = false;
    }

    PhantomClusterWorker.prototype.start = function() {
      var onStart, options,
        _this = this;
      options = {
        binary: this.phantomBinary,
        port: this.phantomBasePort + cluster.worker.id + 1,
        onStdout: this.onStdout,
        onStderr: this.onStderr,
        onExit: function() {
          _this.emit("phantomDied");
          return _this.stop();
        }
      };
      onStart = function(ph) {
        var i, _i, _ref, _results;
        _this.ph = ph;
        _this.emit("phantomStarted");
        _results = [];
        for (i = _i = 0, _ref = _this.parallelism; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(_this.next());
        }
        return _results;
      };
      phantom.create.apply(phantom, this.phantomArguments.concat([options, onStart]));
      return this.emit("started");
    };

    PhantomClusterWorker.prototype.next = function() {
      if (!this.done) {
        if (this.iterations > 0) {
          this.iterations--;
          return this.emit("workerReady");
        } else if (this.pendingRequestCount <= 0) {
          return this.stop();
        }
      }
    };

    PhantomClusterWorker.prototype.stop = function() {
      if (!this.done) {
        this.done = true;
        this.emit("stopped");
        return process.nextTick(function() {
          return process.exit(0);
        });
      }
    };

    return PhantomClusterWorker;

  })(events.EventEmitter);

  PhantomQueuedClusterServer = (function(_super) {
    __extends(PhantomQueuedClusterServer, _super);

    function PhantomQueuedClusterServer(options) {
      this._onWorkerStarted = __bind(this._onWorkerStarted, this);
      options = options || {};
      PhantomQueuedClusterServer.__super__.constructor.call(this, options);
      this.messageTimeout = options.messageTimeout || DEFAULT_MESSAGE_TIMEOUT;
      this._sentMessages = {};
      this._messageIdCounter = 0;
      this.itemsQueue = [];
      this.workersQueue = [];
      this.on("workerStarted", this._onWorkerStarted);
    }

    PhantomQueuedClusterServer.prototype.enqueue = function(request) {
      var item, sent,
        _this = this;
      item = new QueueItem(this._messageIdCounter++, request);
      request.id = item.id;
      item.on("timeout", function() {
        return delete _this._sentMessages[item.id];
      });
      sent = false;
      while (this.workersQueue.length > 0 && !sent) {
        sent = this._sendQueueItemRequest(this.workersQueue.shift(), item);
      }
      if (!sent) {
        this.itemsQueue.push(item);
      }
      return item;
    };

    PhantomQueuedClusterServer.prototype._onWorkerStarted = function(worker) {
      var _this = this;
      return worker.on("message", function(json) {
        var item, sent;
        if (json.action === "queueItemRequest") {
          if (_this.itemsQueue.length > 0) {
            item = _this.itemsQueue.shift();
            sent = _this._sendQueueItemRequest(worker, item);
            if (!sent) {
              return _this.enqueue(item.request);
            }
          } else {
            return _this.workersQueue.push(worker);
          }
        } else if (json.action === "queueItemResponse") {
          item = _this._sentMessages[json.id];
          if (item) {
            item.finish(json.response);
            delete _this._sentMessages[json.id];
            return worker.send({
              action: "queueItemResponse",
              status: "OK"
            });
          } else {
            return worker.send({
              action: "queueItemResponse",
              status: "ignored"
            });
          }
        }
      });
    };

    PhantomQueuedClusterServer.prototype._sendQueueItemRequest = function(worker, item) {
      try {
        worker.send({
          action: "queueItemRequest",
          id: item.id,
          request: item.request
        });
      } catch (_error) {
        return false;
      }
      item.start(this.messageTimeout);
      item.on("timeout", function() {
        try {
          return worker.send({
            action: "queueItemTimeout",
            id: item.id
          });
        } catch (_error) {
          return false;
        }
      });
      this._sentMessages[item.id] = item;
      return true;
    };

    return PhantomQueuedClusterServer;

  })(PhantomClusterServer);

  PhantomQueuedClusterWorker = (function(_super) {
    __extends(PhantomQueuedClusterWorker, _super);

    function PhantomQueuedClusterWorker(options) {
      this._onWorkerReady = __bind(this._onWorkerReady, this);
      this._onMessage = __bind(this._onMessage, this);
      options = options || {};
      PhantomQueuedClusterWorker.__super__.constructor.call(this, options);
      this.messageTimeout = options.messageTimeout || DEFAULT_MESSAGE_TIMEOUT;
      this.itemsQueue = [];
      this.on("workerReady", this._onWorkerReady);
      process.on("message", this._onMessage);
    }

    PhantomQueuedClusterWorker.prototype._onMessage = function(json) {
      var item, _ref,
        _this = this;
      if (json.action === "queueItemRequest") {
        item = new QueueItem(json.id, json.request);
        item.on("response", function() {
          process.send({
            action: "queueItemResponse",
            id: item.id,
            response: item.response
          });
          _this.pendingRequestCount--;
          return _this.next();
        });
        item.start(this.messageTimeout);
        this.itemsQueue.push(item);
        if (this.itemsQueue.length > 0 && this.pendingRequestCount < this.itemsQueue.length) {
          this.emit("request", this.itemsQueue.shift());
          return this.pendingRequestCount++;
        }
      } else if (json.action === "queueItemResponse") {
        if ((_ref = json.status) !== "OK" && _ref !== "ignored") {
          throw new Error("Unexpected status code from queueItemResponse message: " + json.status);
        }
      } else if (json.action === "queueItemTimeout") {
        return this.emit("queueItemTimeout", json.id);
      }
    };

    PhantomQueuedClusterWorker.prototype._onWorkerReady = function() {
      return process.send({
        action: "queueItemRequest"
      });
    };

    return PhantomQueuedClusterWorker;

  })(PhantomClusterWorker);

  QueueItem = (function(_super) {
    __extends(QueueItem, _super);

    function QueueItem(id, request) {
      this._onTimeout = __bind(this._onTimeout, this);
      this.id = id;
      this.request = request;
      this.response = null;
      this.timeout = null;
      this.state = 0;
    }

    QueueItem.prototype.start = function(timeout) {
      if (this.state !== 0) {
        throw new Error("Bad QueueItem state");
      }
      this.state = 1;
      return this.timeout = setTimeout(this._onTimeout, timeout);
    };

    QueueItem.prototype.finish = function(response) {
      if (this.state !== 1) {
        throw new Error("Bad QueueItem state");
      }
      clearTimeout(this.timeout);
      this.timeout = null;
      this.response = response;
      this.state = 2;
      return this.emit("response");
    };

    QueueItem.prototype._onTimeout = function() {
      return this.emit("timeout");
    };

    return QueueItem;

  })(events.EventEmitter);

  exports.create = create;

  exports.createQueued = createQueued;

  exports.PhantomClusterServer = PhantomClusterServer;

  exports.PhantomClusterWorker = PhantomClusterWorker;

  exports.PhantomQueuedClusterServer = PhantomQueuedClusterServer;

  exports.PhantomQueuedClusterWorker = PhantomQueuedClusterWorker;

  exports.QueueItem = QueueItem;

}).call(this);
