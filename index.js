// Generated by CoffeeScript 1.6.3
(function() {
  var DEFAULT_MESSAGE_TIMEOUT, DEFAULT_WORKER_ITERATIONS, DEFAULT_ZMQ_CONNECTION_STRING, POLL_QUEUE_ITEM_INTERVAL, PhantomClusterClient, PhantomClusterServer, PhantomQueuedClusterClient, PhantomQueuedClusterServer, QueueItem, STOP_QUEUE_CHECKING_INTERVAL, cluster, create, createQueued, empty, events, phantom, zmq,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  phantom = require("phantom");

  cluster = require("cluster");

  events = require("events");

  zmq = require("zmq");

  DEFAULT_WORKER_ITERATIONS = 100;

  STOP_QUEUE_CHECKING_INTERVAL = 10;

  DEFAULT_MESSAGE_TIMEOUT = 60 * 1000;

  POLL_QUEUE_ITEM_INTERVAL = 10;

  DEFAULT_ZMQ_CONNECTION_STRING = "ipc:///tmp/phantom-cluster";

  empty = function(obj) {
    var key;
    for (key in obj) {
      return false;
    }
    return true;
  };

  create = function(options) {
    if (cluster.isMaster) {
      return new PhantomClusterServer(options);
    } else {
      return new PhantomClusterClient(options);
    }
  };

  createQueued = function(options) {
    if (cluster.isMaster) {
      return new PhantomQueuedClusterServer(options);
    } else {
      return new PhantomQueuedClusterClient(options);
    }
  };

  PhantomClusterServer = (function(_super) {
    __extends(PhantomClusterServer, _super);

    function PhantomClusterServer(options) {
      PhantomClusterServer.__super__.constructor.apply(this, arguments);
      this.numWorkers = options.workers || require("os").cpus().length;
      this.workers = {};
      this.done = false;
    }

    PhantomClusterServer.prototype.addWorker = function() {
      var worker;
      worker = cluster.fork();
      this.workers[worker.id] = worker;
      return this.emit("workerStarted", worker);
    };

    PhantomClusterServer.prototype.start = function() {
      var i, _i, _ref,
        _this = this;
      cluster.on("exit", function(worker, code, signal) {
        _this.emit("workerDied", worker, code, signal);
        delete _this.workers[worker.id];
        if (!_this.done) {
          return _this.addWorker();
        }
      });
      for (i = _i = 0, _ref = this.numWorkers; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.addWorker();
      }
      return this.emit("started");
    };

    PhantomClusterServer.prototype.stop = function() {
      var worker, _, _ref;
      if (!this.done) {
        this.done = true;
        _ref = this.workers;
        for (_ in _ref) {
          worker = _ref[_];
          worker.kill();
        }
        return this.emit("stopped");
      }
    };

    return PhantomClusterServer;

  })(events.EventEmitter);

  PhantomClusterClient = (function(_super) {
    __extends(PhantomClusterClient, _super);

    function PhantomClusterClient(options) {
      PhantomClusterClient.__super__.constructor.apply(this, arguments);
      this.ph = null;
      this.iterations = options.workerIterations || DEFAULT_WORKER_ITERATIONS;
      this.phantomArguments = options.phantomArguments || [];
      this.phantomBinary = options.phantomBinary || require("phantomjs").path;
      this.phantomBasePort = this.phantomBasePort || 12300;
      this.done = false;
    }

    PhantomClusterClient.prototype.start = function() {
      var onStart, options,
        _this = this;
      options = {
        binary: this.phantomBinary,
        port: this.phantomBasePort + cluster.worker.id + 1,
        onExit: function() {
          _this.emit("phantomDied");
          return _this.stop();
        }
      };
      onStart = function(ph) {
        _this.ph = ph;
        _this.emit("phantomStarted");
        return _this.next();
      };
      phantom.create.apply(phantom, this.phantomArguments.concat([options, onStart]));
      return this.emit("started");
    };

    PhantomClusterClient.prototype.next = function() {
      if (!this.done) {
        this.iterations--;
        if (this.iterations >= 0) {
          return this.emit("workerReady");
        } else {
          return this.stop();
        }
      }
    };

    PhantomClusterClient.prototype.stop = function() {
      if (!this.done) {
        this.done = true;
        this.emit("stopped");
        return process.nextTick(function() {
          return process.exit(0);
        });
      }
    };

    return PhantomClusterClient;

  })(events.EventEmitter);

  PhantomQueuedClusterServer = (function(_super) {
    __extends(PhantomQueuedClusterServer, _super);

    function PhantomQueuedClusterServer(options) {
      this._onSocketMessage = __bind(this._onSocketMessage, this);
      this._onStop = __bind(this._onStop, this);
      this._onStart = __bind(this._onStart, this);
      PhantomQueuedClusterServer.__super__.constructor.call(this, options);
      this.zmqConnectionString = options.zmqConnectionString || DEFAULT_ZMQ_CONNECTION_STRING;
      this.messageTimeout = options.messageTimeout || DEFAULT_MESSAGE_TIMEOUT;
      this._sentMessages = {};
      this._messageIdCounter = 0;
      this._stopCheckingInterval = null;
      this.queue = [];
      this._socket = zmq.socket("rep");
      this._socket.bindSync(this.zmqConnectionString);
      this._socket.on("message", this._onSocketMessage);
      this.on("started", this._onStart);
      this.on("stopped", this._onStop);
    }

    PhantomQueuedClusterServer.prototype.enqueue = function(request) {
      var item,
        _this = this;
      item = new QueueItem(this._messageIdCounter++, request);
      item.on("timeout", function() {
        delete _this._sentMessages[item.id];
        return _this.enqueue(request);
      });
      this.queue.push(item);
      return item;
    };

    PhantomQueuedClusterServer.prototype._onStart = function() {
      var _this = this;
      return this._stopCheckingInterval = setInterval(function() {
        if (!_this.done && _this.queue.length === 0 && empty(_this._sentMessages)) {
          return _this.stop();
        }
      }, STOP_QUEUE_CHECKING_INTERVAL);
    };

    PhantomQueuedClusterServer.prototype._onStop = function() {
      if (this._stopCheckingInterval !== null) {
        clearInterval(this._stopCheckingInterval);
      }
      return this._socket.close();
    };

    PhantomQueuedClusterServer.prototype._onSocketMessage = function(message) {
      var item, json;
      json = JSON.parse(message.toString());
      if (json.action === "queueItemRequest") {
        if (this.queue.length > 0) {
          item = this.queue.shift();
          item.start(this.messageTimeout);
          this._socket.send(JSON.stringify({
            action: "queueItemRequest",
            id: item.id,
            request: item.request
          }));
          return this._sentMessages[item.id] = item;
        } else {
          return this._socket.send(JSON.stringify({
            action: "done"
          }));
        }
      } else if (json.action === "queueItemResponse") {
        item = this._sentMessages[json.id];
        if (item) {
          item.finish(json.response);
          delete this._sentMessages[json.id];
          return this._socket.send(JSON.stringify({
            action: "OK"
          }));
        } else {
          return this._socket.send(JSON.stringify({
            action: "ignored"
          }));
        }
      }
    };

    return PhantomQueuedClusterServer;

  })(PhantomClusterServer);

  PhantomQueuedClusterClient = (function(_super) {
    __extends(PhantomQueuedClusterClient, _super);

    function PhantomQueuedClusterClient(options) {
      this._onPhantomStarted = __bind(this._onPhantomStarted, this);
      this._onSocketMessage = __bind(this._onSocketMessage, this);
      this._onStop = __bind(this._onStop, this);
      PhantomQueuedClusterClient.__super__.constructor.call(this, options);
      this.zmqConnectionString = options.zmqConnectionString || DEFAULT_ZMQ_CONNECTION_STRING;
      this.currentRequestId = null;
      this._socket = zmq.socket("req");
      this._socket.connect(this.zmqConnectionString);
      this._socket.on("message", this._onSocketMessage);
      this.on("stopped", this._onStop);
      this.on("workerReady", this._onPhantomStarted);
    }

    PhantomQueuedClusterClient.prototype.queueItemResponse = function(response) {
      this._socket.send(JSON.stringify({
        action: "queueItemResponse",
        id: this.currentRequestId,
        response: response
      }));
      return this.next();
    };

    PhantomQueuedClusterClient.prototype._onStop = function() {
      return this._socket.close();
    };

    PhantomQueuedClusterClient.prototype._onSocketMessage = function(message) {
      var json, _ref;
      json = JSON.parse(message.toString());
      if (json.action === "queueItemRequest") {
        this.currentRequestId = json.id;
        return this.emit("queueItemReady", json.request);
      } else if (json.action === "queueItemResponse") {
        if ((_ref = json.status) !== "OK" && _ref !== "ignored") {
          throw new Error("Unexpected status code from queueItemResponse message: " + json.status);
        }
      } else if (json.action === "done") {
        return this.stop();
      }
    };

    PhantomQueuedClusterClient.prototype._onPhantomStarted = function() {
      return this._socket.send(JSON.stringify({
        action: "queueItemRequest"
      }));
    };

    return PhantomQueuedClusterClient;

  })(PhantomClusterClient);

  QueueItem = (function(_super) {
    __extends(QueueItem, _super);

    function QueueItem(id, request, timeout) {
      this._timeout = __bind(this._timeout, this);
      this.id = id;
      this.request = request;
      this.response = null;
      this.timeout = null;
    }

    QueueItem.prototype.start = function(timeout) {
      return this.timeout = setTimeout(this._timeout, timeout);
    };

    QueueItem.prototype.finish = function(response) {
      if (this.timeout) {
        clearTimeout(this.timeout);
      }
      this.response = response;
      return this.emit("response");
    };

    QueueItem.prototype._timeout = function() {
      return this.emit("timeout");
    };

    return QueueItem;

  })(events.EventEmitter);

  exports.create = create;

  exports.createQueued = createQueued;

  exports.PhantomClusterServer = PhantomClusterServer;

  exports.PhantomClusterClient = PhantomClusterClient;

  exports.PhantomQueuedClusterServer = PhantomQueuedClusterServer;

  exports.PhantomQueuedClusterClient = PhantomQueuedClusterClient;

}).call(this);
